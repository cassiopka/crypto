[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "atbash_cipher",
        "importPath": "ciphers.atbash_cipher",
        "description": "ciphers.atbash_cipher",
        "isExtraImport": true,
        "detail": "ciphers.atbash_cipher",
        "documentation": {}
    },
    {
        "label": "atbash_decipher",
        "importPath": "ciphers.atbash_cipher",
        "description": "ciphers.atbash_cipher",
        "isExtraImport": true,
        "detail": "ciphers.atbash_cipher",
        "documentation": {}
    },
    {
        "label": "caesar_cipher",
        "importPath": "ciphers.caesar_cipher",
        "description": "ciphers.caesar_cipher",
        "isExtraImport": true,
        "detail": "ciphers.caesar_cipher",
        "documentation": {}
    },
    {
        "label": "caesar_decipher",
        "importPath": "ciphers.caesar_cipher",
        "description": "ciphers.caesar_cipher",
        "isExtraImport": true,
        "detail": "ciphers.caesar_cipher",
        "documentation": {}
    },
    {
        "label": "polybius_square_cipher",
        "importPath": "ciphers.polybius_square_cipher",
        "description": "ciphers.polybius_square_cipher",
        "isExtraImport": true,
        "detail": "ciphers.polybius_square_cipher",
        "documentation": {}
    },
    {
        "label": "polybius_square_decipher",
        "importPath": "ciphers.polybius_square_cipher",
        "description": "ciphers.polybius_square_cipher",
        "isExtraImport": true,
        "detail": "ciphers.polybius_square_cipher",
        "documentation": {}
    },
    {
        "label": "trithemius_cipher",
        "importPath": "ciphers.trithemius_cipher",
        "description": "ciphers.trithemius_cipher",
        "isExtraImport": true,
        "detail": "ciphers.trithemius_cipher",
        "documentation": {}
    },
    {
        "label": "trithemius_decipher",
        "importPath": "ciphers.trithemius_cipher",
        "description": "ciphers.trithemius_cipher",
        "isExtraImport": true,
        "detail": "ciphers.trithemius_cipher",
        "documentation": {}
    },
    {
        "label": "belazo_cipher",
        "importPath": "ciphers.belazo_cipher",
        "description": "ciphers.belazo_cipher",
        "isExtraImport": true,
        "detail": "ciphers.belazo_cipher",
        "documentation": {}
    },
    {
        "label": "belazo_decipher",
        "importPath": "ciphers.belazo_cipher",
        "description": "ciphers.belazo_cipher",
        "isExtraImport": true,
        "detail": "ciphers.belazo_cipher",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ciphers.matrix_cipher",
        "description": "ciphers.matrix_cipher",
        "isExtraImport": true,
        "detail": "ciphers.matrix_cipher",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ciphers.shenon",
        "description": "ciphers.shenon",
        "isExtraImport": true,
        "detail": "ciphers.shenon",
        "documentation": {}
    },
    {
        "label": "format_input",
        "importPath": "utils.input_formatter",
        "description": "utils.input_formatter",
        "isExtraImport": true,
        "detail": "utils.input_formatter",
        "documentation": {}
    },
    {
        "label": "format_input",
        "importPath": "utils.input_formatter",
        "description": "utils.input_formatter",
        "isExtraImport": true,
        "detail": "utils.input_formatter",
        "documentation": {}
    },
    {
        "label": "format_blocks",
        "importPath": "utils.block_formatter",
        "description": "utils.block_formatter",
        "isExtraImport": true,
        "detail": "utils.block_formatter",
        "documentation": {}
    },
    {
        "label": "print_polybius_square",
        "importPath": "utils.print_square",
        "description": "utils.print_square",
        "isExtraImport": true,
        "detail": "utils.print_square",
        "documentation": {}
    },
    {
        "label": "text_to_numeric",
        "importPath": "utils.text_to_numeric",
        "description": "utils.text_to_numeric",
        "isExtraImport": true,
        "detail": "utils.text_to_numeric",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "atbash_cipher",
        "kind": 2,
        "importPath": "ciphers.atbash_cipher",
        "description": "ciphers.atbash_cipher",
        "peekOfCode": "def atbash_cipher(text: str) -> str:\n    \"\"\"Атбаш шифр.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    reverse_alphabet = alphabet[::-1] # переворачиваем алфавит \n    result = ''\n    for char in text:  # проходимся по каждому символу в тексте\n        if char in alphabet:  # если символ присутствует в алфавите\n            index = alphabet.index(char)  # найдем его индекс\n            result += reverse_alphabet[index]  # добавим в результат соответствующий символ из перевернутого алфавита\n        else:",
        "detail": "ciphers.atbash_cipher",
        "documentation": {}
    },
    {
        "label": "atbash_decipher",
        "kind": 2,
        "importPath": "ciphers.atbash_cipher",
        "description": "ciphers.atbash_cipher",
        "peekOfCode": "def atbash_decipher(text: str) -> str:\n    \"\"\"Расшифровка атбаш шифра.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    reverse_alphabet = alphabet[::-1]\n    result = '' \n    for char in text:  # проходимся по каждому символу в тексте\n        if char in reverse_alphabet:  # если символ присутствует в перевернутом алфавите\n            index = reverse_alphabet.index(char)  # найдем его индекс\n            result += alphabet[index]  # добавим в результат соответствующий символ из обычного алфавита\n        else:",
        "detail": "ciphers.atbash_cipher",
        "documentation": {}
    },
    {
        "label": "belazo_cipher",
        "kind": 2,
        "importPath": "ciphers.belazo_cipher",
        "description": "ciphers.belazo_cipher",
        "peekOfCode": "def belazo_cipher(text: str, key: str) -> str:\n    \"\"\"Шифр Белазо.\"\"\"\n    # Создаем таблицу алфавита, каждая строка - сдвиг на 1 букву\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    # Преобразование текста и ключа в нижний регистр\n    text = text.lower()\n    key = key.lower()\n    # Шифрование текста\n    encrypted_text = ''\n    for i, char in enumerate(text):",
        "detail": "ciphers.belazo_cipher",
        "documentation": {}
    },
    {
        "label": "belazo_decipher",
        "kind": 2,
        "importPath": "ciphers.belazo_cipher",
        "description": "ciphers.belazo_cipher",
        "peekOfCode": "def belazo_decipher(text: str, key: str) -> str:\n    \"\"\"Дешифрование шифра Белазо.\"\"\"\n    # Создаем таблицу алфавита, каждая строка - сдвиг на 1 букву\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    # Преобразование текста и ключа в нижний регистр\n    text = text.lower()\n    key = key.lower()\n    # Расшифрованный текст\n    decrypted_text = ''\n    for i, char in enumerate(text):",
        "detail": "ciphers.belazo_cipher",
        "documentation": {}
    },
    {
        "label": "caesar_cipher",
        "kind": 2,
        "importPath": "ciphers.caesar_cipher",
        "description": "ciphers.caesar_cipher",
        "peekOfCode": "def caesar_cipher(text: str, key: int) -> str:\n    \"\"\"Цезарь шифр с выбором ключа.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    encrypted_text = ''.join(alphabet[(alphabet.index(char) + key) % len(alphabet)] for char in text)\n    return encrypted_text\ndef caesar_decipher(text: str, key: int) -> str:\n    \"\"\"Расшифровка цезарь шифра с выбором ключа.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    decrypted_text = ''.join(alphabet[(alphabet.index(char) - key) % len(alphabet)] for char in text)\n    return decrypted_text",
        "detail": "ciphers.caesar_cipher",
        "documentation": {}
    },
    {
        "label": "caesar_decipher",
        "kind": 2,
        "importPath": "ciphers.caesar_cipher",
        "description": "ciphers.caesar_cipher",
        "peekOfCode": "def caesar_decipher(text: str, key: int) -> str:\n    \"\"\"Расшифровка цезарь шифра с выбором ключа.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    decrypted_text = ''.join(alphabet[(alphabet.index(char) - key) % len(alphabet)] for char in text)\n    return decrypted_text",
        "detail": "ciphers.caesar_cipher",
        "documentation": {}
    },
    {
        "label": "matrix_cipher",
        "kind": 2,
        "importPath": "ciphers.matrix_cipher",
        "description": "ciphers.matrix_cipher",
        "peekOfCode": "def matrix_cipher(text_numeric, key_matrix):\n    \"\"\"Матричный шифр.\"\"\"\n    encrypted_messages = []\n    key_size = key_matrix.shape[0]\n    # Подготовка текста к шифрованию: разбиение на векторы длиной key_size\n    text_chunks = [text_numeric[i:i+key_size] for i in range(0, len(text_numeric), key_size)]\n    # Шифрование каждого вектора текста\n    for chunk in text_chunks:\n        # Дополнение вектора нулями до длины key_size, если необходимо\n        while len(chunk) < key_size:",
        "detail": "ciphers.matrix_cipher",
        "documentation": {}
    },
    {
        "label": "matrix_decipher",
        "kind": 2,
        "importPath": "ciphers.matrix_cipher",
        "description": "ciphers.matrix_cipher",
        "peekOfCode": "def matrix_decipher(encrypted_message, key_matrix):\n    \"\"\"Дешифрование матричного шифра.\"\"\"\n    decrypted_messages = []  \n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'  \n    key_size = key_matrix.shape[0]  \n    split_message = encrypted_message.split()  # Разбиваем зашифрованное сообщение на блоки по пробелам\n    vectors = [] \n    for vector_block in split_message:\n        vector_block = vector_block.replace(' ', '')  # Удаляем пробелы из блока\n        vectors.append(vector_block)",
        "detail": "ciphers.matrix_cipher",
        "documentation": {}
    },
    {
        "label": "polybius_square_cipher",
        "kind": 2,
        "importPath": "ciphers.polybius_square_cipher",
        "description": "ciphers.polybius_square_cipher",
        "peekOfCode": "def polybius_square_cipher(text: str) -> str:\n    \"\"\"Квадрат Полибия.\"\"\"\n    # буквы с ключами (ij)  \n    polybius_table = {\n        'а': '11', 'б': '12', 'в': '13', 'г': '14', 'д': '15', 'е': '16',\n        'ж': '21', 'з': '22', 'и': '23', 'й': '24', 'к': '25', 'л': '26',\n        'м': '31', 'н': '32', 'о': '33', 'п': '34', 'р': '35', 'с': '36',\n        'т': '41', 'у': '42', 'ф': '43', 'х': '44', 'ц': '45', 'ч': '46',\n        'ш': '51', 'щ': '52', 'ъ': '53', 'ы': '54', 'ь': '55', 'э': '56',\n        'ю': '61', 'я': '62'",
        "detail": "ciphers.polybius_square_cipher",
        "documentation": {}
    },
    {
        "label": "polybius_square_decipher",
        "kind": 2,
        "importPath": "ciphers.polybius_square_cipher",
        "description": "ciphers.polybius_square_cipher",
        "peekOfCode": "def polybius_square_decipher(text: str) -> str:\n    \"\"\"Расшифровка квадрата Полибия.\"\"\"\n    # буквы с ключами (ij)  \n    polybius_table = {\n        '11': 'а', '12': 'б', '13': 'в', '14': 'г', '15': 'д', '16': 'е',\n        '21': 'ж', '22': 'з', '23': 'и', '24': 'й', '25': 'к', '26': 'л',\n        '31': 'м', '32': 'н', '33': 'о', '34': 'п', '35': 'р', '36': 'с',\n        '41': 'т', '42': 'у', '43': 'ф', '44': 'х', '45': 'ц', '46': 'ч',\n        '51': 'ш', '52': 'щ', '53': 'ъ', '54': 'ы', '55': 'ь', '56': 'э',\n        '61': 'ю', '62': 'я'",
        "detail": "ciphers.polybius_square_cipher",
        "documentation": {}
    },
    {
        "label": "linear_congruential_generator",
        "kind": 2,
        "importPath": "ciphers.shenon",
        "description": "ciphers.shenon",
        "peekOfCode": "def linear_congruential_generator(a, c, t0, modulo=32):\n    if a % 4 != 1:\n        raise ValueError(\"a must be equal to 1 modulo 4\")\n    if c % 2 == 0:\n        raise ValueError(\"c must be an odd number\")\n    sequence = []\n    i = 0\n    t_current = t0\n    while i < 100:\n        i += 1",
        "detail": "ciphers.shenon",
        "documentation": {}
    },
    {
        "label": "process_list",
        "kind": 2,
        "importPath": "ciphers.shenon",
        "description": "ciphers.shenon",
        "peekOfCode": "def process_list(list1, sequence):\n    result = []\n    i = 0\n    while i < len(list1):\n        result.append((list1[i] + sequence[i % len(sequence)]) % 32)\n        i += 1\n    return result\ndef numeric_to_text(numeric_values):\n    \"\"\"Функция для преобразования числового эквивалента в текст.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'",
        "detail": "ciphers.shenon",
        "documentation": {}
    },
    {
        "label": "numeric_to_text",
        "kind": 2,
        "importPath": "ciphers.shenon",
        "description": "ciphers.shenon",
        "peekOfCode": "def numeric_to_text(numeric_values):\n    \"\"\"Функция для преобразования числового эквивалента в текст.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    text = ''\n    for value in numeric_values:\n        if 1 <= value <= len(alphabet):\n            text += alphabet[value - 1]\n    return text\ndef decrypt_text(numeric_values, sequence):\n    result = []",
        "detail": "ciphers.shenon",
        "documentation": {}
    },
    {
        "label": "decrypt_text",
        "kind": 2,
        "importPath": "ciphers.shenon",
        "description": "ciphers.shenon",
        "peekOfCode": "def decrypt_text(numeric_values, sequence):\n    result = []\n    for i in range(len(sequence)):\n        result.append((numeric_values[i] - sequence[i]) % 32)\n    return result",
        "detail": "ciphers.shenon",
        "documentation": {}
    },
    {
        "label": "trithemius_cipher",
        "kind": 2,
        "importPath": "ciphers.trithemius_cipher",
        "description": "ciphers.trithemius_cipher",
        "peekOfCode": "def trithemius_cipher(text: str) -> str:\n    \"\"\"Функция для шифрования текста методом Тритемия.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя' \n    n = len(alphabet)\n    encrypted_text = ''\n    for j, char in enumerate(text, start=1):  # перебираем символы текста, начиная с индекса 1\n        i = alphabet.index(char) + j - 1  # находим новый индекс символа\n        encrypted_text += alphabet[i % n]  # добавляем зашифрованный символ к зашифрованному тексту\n    return encrypted_text\ndef trithemius_decipher(text: str) -> str:",
        "detail": "ciphers.trithemius_cipher",
        "documentation": {}
    },
    {
        "label": "trithemius_decipher",
        "kind": 2,
        "importPath": "ciphers.trithemius_cipher",
        "description": "ciphers.trithemius_cipher",
        "peekOfCode": "def trithemius_decipher(text: str) -> str:\n    \"\"\"Функция для расшифровки текста, зашифрованного методом Тритемия.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'  \n    n = len(alphabet)\n    decrypted_text = ''\n    for j, char in enumerate(text, start=1):  # перебираем символы текста, начиная с индекса 1\n        i = alphabet.index(char) - j + 1  # находим новый индекс символа\n        decrypted_text += alphabet[i % n]  # добавляем расшифрованный символ к расшифрованному тексту\n    return decrypted_text",
        "detail": "ciphers.trithemius_cipher",
        "documentation": {}
    },
    {
        "label": "VerticalPermutation",
        "kind": 6,
        "importPath": "ciphers.vertical",
        "description": "ciphers.vertical",
        "peekOfCode": "class VerticalPermutation:\n    key_string = \"аб\"\n    example_alphabet = ('а', 'б', 'в', 'г', 'д', 'е', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я')\n    def __init__(self, key):\n        self.key = key\n    @staticmethod\n    def key_to_int(key_string):\n        positions = [-1] * len(key_string)\n        for i, char in enumerate(key_string):\n            if char in VerticalPermutation.example_alphabet:",
        "detail": "ciphers.vertical",
        "documentation": {}
    },
    {
        "label": "format_blocks",
        "kind": 2,
        "importPath": "utils.block_formatter",
        "description": "utils.block_formatter",
        "peekOfCode": "def format_blocks(text: str) -> str:\n    \"\"\"Разделение строки на блоки по 5 символов.\"\"\"\n    return ' '.join([text[i:i+5] for i in range(0, len(text), 5)])",
        "detail": "utils.block_formatter",
        "documentation": {}
    },
    {
        "label": "format_output",
        "kind": 2,
        "importPath": "utils.format_output",
        "description": "utils.format_output",
        "peekOfCode": "def format_output(text: str) -> str:\n    \"\"\"Форматирование выходной строки.\"\"\"\n    formatted_text = text.replace('тире', '-').replace('зпт', ',').replace('тчк', '.')\n    return formatted_text",
        "detail": "utils.format_output",
        "documentation": {}
    },
    {
        "label": "format_input",
        "kind": 2,
        "importPath": "utils.input_formatter",
        "description": "utils.input_formatter",
        "peekOfCode": "def format_input(text: str) -> str:\n    \"\"\"Форматирование входной строки.\"\"\"\n    formatted_text = text.lower().replace('.', 'тчк').replace(',', 'зпт').replace('-', 'тире').replace(' ', '')\n    return formatted_text",
        "detail": "utils.input_formatter",
        "documentation": {}
    },
    {
        "label": "print_polybius_square",
        "kind": 2,
        "importPath": "utils.print_square",
        "description": "utils.print_square",
        "peekOfCode": "def print_polybius_square():\n    \"\"\"Вывод квадрата Полибия на экран.\"\"\"\n    print(\"Квадрат Полибия:\")\n    print(\"  1 2 3 4 5 6\")\n    print(\"1 а б в г д е\")\n    print(\"2 ж з и й к л\")\n    print(\"3 м н о п р с\")\n    print(\"4 т у ф х ц ч\")\n    print(\"5 ш щ ъ ы ь э\")\n    print(\"6 ю я\")",
        "detail": "utils.print_square",
        "documentation": {}
    },
    {
        "label": "text_to_numeric",
        "kind": 2,
        "importPath": "utils.text_to_numeric",
        "description": "utils.text_to_numeric",
        "peekOfCode": "def text_to_numeric(text):\n    \"\"\"Функция для преобразования текста в числовой эквивалент.\"\"\"\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    numeric_values = []\n    for char in text:\n        if char.lower() in alphabet:\n            numeric_value = alphabet.index(char.lower()) + 1\n            numeric_values.append(numeric_value)\n    return numeric_values",
        "detail": "utils.text_to_numeric",
        "documentation": {}
    },
    {
        "label": "input_key_matrix",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def input_key_matrix(size):\n    \"\"\"Функция для ввода ключевой матрицы.\"\"\"\n    key_matrix = []\n    print(\"Введите элементы ключевой матрицы построчно:\")\n    for _ in range(size):\n        row = list(map(int, input().split()))\n        key_matrix.append(row)\n    return np.array(key_matrix)\ndef main():\n    while True:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main():\n    while True:\n        print(\"Выберите действие:\")\n        print(\"1. Зашифровать текст\")\n        print(\"2. Расшифровать текст\")\n        print(\"0. Выйти\")\n        action_choice = input(\"Введите номер действия: \")\n        if action_choice == '0':\n            print(\"Выход из программы.\")\n            break",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "extended_gcd",
        "kind": 2,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "def extended_gcd(a, b):\n    x, y, u, v = 0, 1, 1, 0\n    while a != 0:\n        q = b // a\n        b, a, u, v = a, b % a, v, u - q * v\n        x, y = y, x - q * y\n    return b, x, y\ndef modular_inverse(e, fi):\n    gcd, x, y = extended_gcd(e, fi)\n    if gcd != 1:",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "modular_inverse",
        "kind": 2,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "def modular_inverse(e, fi):\n    gcd, x, y = extended_gcd(e, fi)\n    if gcd != 1:\n        raise ValueError(\"e и fi не являются взаимно простыми\")\n    return x % fi\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\ndef find_position(letter, alphabet):",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "gcd",
        "kind": 2,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\ndef find_position(letter, alphabet):\n    return alphabet.index(letter)\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "find_position",
        "kind": 2,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "def find_position(letter, alphabet):\n    return alphabet.index(letter)\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "is_prime",
        "kind": 2,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "generate_keys",
        "kind": 2,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "def generate_keys():\n    while True:\n        p = int(input(\"Введите простое число p (> 2): \"))\n        if is_prime(p) and p > 2:\n            break\n        else:\n            print(\"Число p должно быть простым и больше 2. Попробуйте еще раз.\")\n    while True:\n        q = int(input(\"Введите простое число q (> 2): \"))\n        if is_prime(q) and q > 2 and q != p:",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "encrypt",
        "kind": 2,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "def encrypt(text, key):\n    e, n = key\n    encrypted_text = []\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    for char in text:\n        if char not in alphabet:\n            print(\"Недопустимый символ в тексте. Допускаются только строчные буквы русского алфавита.\")\n            return None\n        position = find_position(char, alphabet) + 1\n        encrypted_position = pow(position, e, n)",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "decrypt",
        "kind": 2,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "def decrypt(encrypted_text, key):\n    d, n = key\n    decrypted_text = []\n    alphabet = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'\n    for position in encrypted_text:\n        decrypted_position = pow(position, d, n)\n        decrypted_char = alphabet[decrypted_position - 1]\n        decrypted_text.append(decrypted_char)\n    return ''.join(decrypted_text)\nif __name__ == \"__main__\":",
        "detail": "test",
        "documentation": {}
    }
]